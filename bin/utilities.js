"use strict";
// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnv = getEnv;
exports.getEnvBoolean = getEnvBoolean;
exports.getEnvNumber = getEnvNumber;
exports.getVersion = getVersion;
exports.resourceOptsDefaults = resourceOptsDefaults;
exports.lazyLoad = lazyLoad;
exports.callAsync = callAsync;
exports.getPackage = getPackage;
const resproto = require("@pulumi/pulumi/proto/resource_pb");
const mutex = require("async-mutex");
const runtime = require("@pulumi/pulumi/runtime");
function getEnv(...vars) {
    for (const v of vars) {
        const value = process.env[v];
        if (value) {
            return value;
        }
    }
    return undefined;
}
function getEnvBoolean(...vars) {
    const s = getEnv(...vars);
    if (s !== undefined) {
        // NOTE: these values are taken from https://golang.org/src/strconv/atob.go?s=351:391#L1, which is what
        // Terraform uses internally when parsing boolean values.
        if (["1", "t", "T", "true", "TRUE", "True"].find(v => v === s) !== undefined) {
            return true;
        }
        if (["0", "f", "F", "false", "FALSE", "False"].find(v => v === s) !== undefined) {
            return false;
        }
    }
    return undefined;
}
function getEnvNumber(...vars) {
    const s = getEnv(...vars);
    if (s !== undefined) {
        const f = parseFloat(s);
        if (!isNaN(f)) {
            return f;
        }
    }
    return undefined;
}
function getVersion() {
    let version = require('./package.json').version;
    // Node allows for the version to be prefixed by a "v", while semver doesn't.
    // If there is a v, strip it off.
    if (version.indexOf('v') === 0) {
        version = version.slice(1);
    }
    return version;
}
/** @internal */
function resourceOptsDefaults() {
    return { version: getVersion() };
}
/** @internal */
function lazyLoad(exports, props, loadModule) {
    for (let property of props) {
        Object.defineProperty(exports, property, {
            enumerable: true,
            get: function () {
                return loadModule()[property];
            },
        });
    }
}
/** @internal */
async function callAsync(tok, props, res, opts) {
    const o = runtime.call(tok, props, res);
    const value = await o.promise(true /*withUnknowns*/);
    const isKnown = await o.isKnown;
    const isSecret = await o.isSecret;
    const problem = !isKnown ? "an unknown value"
        : isSecret ? "a secret value"
            : undefined;
    // Ingoring o.resources silently. They are typically non-empty, r.f() calls include r as a dependency.
    if (problem) {
        throw new Error(`Plain resource method "${tok}" incorrectly returned ${problem}. ` +
            "This is an error in the provider, please report this to the provider developer.");
    }
    // Extract a single property if requested.
    if (opts && opts.property) {
        return value[opts.property];
    }
    return value;
}
const _packageLock = new mutex.Mutex();
var _packageRef = undefined;
async function getPackage() {
    if (_packageRef === undefined) {
        if (!runtime.supportsParameterization()) {
            throw new Error("The Pulumi CLI does not support parameterization. Please update the Pulumi CLI");
        }
        await _packageLock.acquire();
        if (_packageRef === undefined) {
            const monitor = runtime.getMonitor();
            const params = new resproto.Parameterization();
            params.setName("spacelift-terraform-provider");
            params.setVersion("1.31.0");
            params.setValue(Uint8Array.from(atob("eyJyZW1vdGUiOnsidXJsIjoicmVnaXN0cnkub3BlbnRvZnUub3JnL3NwYWNlbGlmdC1pby9zcGFjZWxpZnQiLCJ2ZXJzaW9uIjoiMS4zMS4wIn0sInByb3ZpZGVyTmFtZSI6InNwYWNlbGlmdC10ZXJyYWZvcm0tcHJvdmlkZXIifQ=="), c => c.charCodeAt(0)));
            const req = new resproto.RegisterPackageRequest();
            req.setName("terraform-provider");
            req.setVersion("0.13.0");
            req.setDownloadUrl("");
            req.setParameterization(params);
            const resp = await new Promise((resolve, reject) => {
                monitor.registerPackage(req, (err, resp) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(resp);
                    }
                });
            });
            _packageRef = resp.getRef();
        }
        _packageLock.release();
    }
    return _packageRef;
}
//# sourceMappingURL=utilities.js.map